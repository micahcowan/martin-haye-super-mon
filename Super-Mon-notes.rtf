{\rtf1\ansi\ansicpg1252\cocoartf949\cocoasubrtf540
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww9140\viewh13520\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f0\fs24 \cf0 Summary of new commands:\
	
\f1 LABEL=890
\f0 		Set label\
	
\f1 LABEL=0
\f0 		Delete label\
	
\f1 300: LDA #3
\f0 	In-line mini asm (must have space before opcode)\
	
\f1 300: LDA LABEL
\f0 	Can use labels in mini-asm. Also, listings have labels.\
	
\f1 800.8FFT
\f0 		Print labels in given memory range\
	
\f1 300: LDA LAB+1
\f0 	Can add numbers to a label\
	
\f1 LABELG
\f0 		To act on label (e.g. Go, List, etc.)\
	
\f1 300: BEQ *
\f0 		Can use * for current PC\
	
\f1 X
\f0 			Fwd branch fixer: last "
\f1 B
\f0\i xx
\f1\i0  *
\f0 " changed to current PC\
	
\f1 3000.3FFFZ
\f0 		Fill ("Zap") with zeros\
	
\f1 AA<3000.3FFFZ
\f0 	Fill with specified value\
	
\f1 2000:"ABC"		
\f0 Put ASCII text in mem
\f1 \
	2000:"A""B" 8D	
\f0 How to embed a quote char, or follow w/ hex
\f1 \
	"A"			
\f0 Quick way to find out ASCII code\
	
\f1 800.CFFP
\f0 		Set program area for reloc scans\
	
\f1 806<800.830M
\f0 	Move with correct handling of overlapping range\
	
\f1 806<800.830S
\f0 	Same as M)ove, but also rel, abs, and label relocation.\
				Source must be within P)rogram range.\
	
\f1 800I
\f0 			Insert 16 program bytes at 800 (leaves PC=800)\
	
\f1 800.805I
\f0 		Insert 5 program bytes at 800 (leaves PC=800)\
	
\f1 800O
\f0 			Like Insert, but \
	
\f1 800K
\f0 			Klose (delete) set of zero-bytes starting at 800\
	
\f1 800.805K
\f0 		Klose (delete) 6 (six) program bytes at 800, zeroed or not.\
	
\f1 2000.207F
\f0 		Dump memory range, with ASCII alongside.\
	
\f1 DF10<6000.67FFW	
\f0 Write 8 pages, $6000.67FF, to disk file $10.\
	
\f1 DF10<0W		
\f0 Delete disk file $10.\
	
\f1 6000<DF10R		
\f0 Read disk file $10 to $6000 (the whole file)\
	
\f1 0R 
\f0 or just  
\f1 R		
\f0 Print disk catalog\
\
Zero-page:\
	50	PTMP\
	52	QTMP\
	54	PSYM\
	56	BITCOUNT\
	57	YSAVE\
	58	PROGBEG\
	5A	PROGEND\
	5C	MOVELEN\
	5E	TARGET\
	60	DSTEND\
\
RWSECS	E070	Read/write # sectors in A, print ERR & goto mon if err.\
WOZRELOC	E072	Woz relocator\
COLDST	E000	Cold start\
WARMST	E003	Warm start\
MONLUP	E009	Mon main loop patch\
MONSPC	E00C	Mon space patch ($FF >= #81)\
XBRFIX	E00F	'X' forward branch fixer\
PRERRX	E012	Print ERR, jump to mon\
XMON	E015	Reset stack, jump to mon\
GETNUM0	E018	Normal getnum without patches, using $34 for Y\
GETNUMR	E01B	Resume getnum having put num in $3E/3F and advanced $34\
GNUMPC	E01E	Getnum patch "*" ($FF >= #82)	\
SHFTBITS		Shift Y bits from A into SYMBUF; (low bit first);\
			decrement BITCOUNT and go to err if no more\
ENCHAR		Encode char in A if sym char; sec if so else clc.\
ENSYM		Encode symbol $200,Y to SYMBUF. Y adv to next after sym.\
			sec if at least 3 chars, else clc.\
SHFTBITS		Shift down SYMBUF by X bits\
CHDECOD		Decode 1 char from SYMBUF\
SYMDECOD		Decode and print symbol (PSYM)\
AXDEC	E05D	decrement A/X\
AXINC	E060	increment A/X\
BUMPSYM	E021	Bump PSYM, sec if ok, clc if at end.\
FSYMSLOT		Look for open slot and add sym name SYMBUF. Jump to err if full.\
GLBSET		Getnum patch: label set/get\
SYMSCAN		Symbol scan (optimized): SYMBUF against sym tbl.\
			PSYM set and sec if found. If sym value is zero, no match.\
GPLUS		Resume getnum after checking for "+"\
BLDHASH		Rebuild hash table, set hash marker\
PRSYMTBL	E024	"T" handler: Print symbols in address range A1..A2\
CHKSYM	E027	Check if A1 ($3C/3D) is symbol; if so sec and set PSYM\
PGPATCH		Paging patch: expects count on stack; destroys A and X\
BLDHASHZ	E02A	Rebuild hash table only if necessary.\
LSADR	E02D	Patch: address printing in disassembly (FF:>=84 to enable)\
LSLAB	E030	Patch: label header in disassembly (FF>=85 to enable)\
RWSYM		Read/write symbol tbl\
MONZAP	E033	"Z" zap handler\
LSLUP	E048	Patch: replacement List loop (counter in BITCOUNT)\
MKINS		Re-create instruction length table\
SUBD		E039	Subtract: (0,X) - (0,Y) -> (0,A) (preserves all regs)\
READROM		Read ROM\
WRITEROM	E006	Write ROM\
CMPD	E03C	Set carry if (0,X) >= (0,Y) (preserves all regs)\
ADDD		E03F	Add: (0,X) + (0,Y) -> (0,A) (preserves all regs)\
OVLMOVE		Mon overlapping move handler (FF>=86 to enable)\
INCD		E042	Increment (0,X) (preserves all regs)\
DECD		E045	Decrement (0,X) (preserves all regs)\
COLDSTP		Patch: cold start - read sym tbl, clear PROGBEG and PROGEND\
SETPROG	E04B	"P" prog range handler\
MKPGTB2		sub: for page tbl building\
MKPGTBL		Build table of pages that need rel checking ($80) and pages that\
			are in SRCBEG.SRCEND ($01 or $81) at $200.2FF\
FIXINBUF		sub: fill $200.2FF with 8D\
RELSCAN		Relocation scanning loop\
SMRTMVB		Smart move with relocate (FF>=87 to enable)\
CALCQT		sub: calc PTMP,Y -> QTMP, save Y in YSAVE\
DISQTMP		sub: CR, then disassemble QTMP (no CR after)\
INCINSFX		sub: increment INSFIXCT\
BETWEEND	E054	sec if (0,X) <= (0,A) <= (0,Y) (preserves all regs)\
DSQTMP2		sub: calc PTMP,Y, save Y, sec if QTMP between PROGBEG..END\
ABSRELOC	E04E	Absolute instruction relocate\
FIXBRNCH		Fix rel branch at (QTMP) to TARGET and print it. ERR and clc if far.\
CALCBR		Compute target of branch at (QTMP) -> TARGET.\
RELRELOC	E051	Relative instruction relocate\
AXMAX	E057	Select max(A/X vs. 0,Y) -> A/X\
AXMIN	E05A	Select min(A/X vs 0,Y) -> A/X\
AXPCLMP		sub: Clamp A/X between PROGBEG..PROGEND+1\
NONOVL		sub: calc non-overlapping part of smart move to clear\
SMRTMVC		Relocate with remainder range clear (FF>=88 to enable)\
RELSYM		sub: relocate symbols in SRCBEG.SRCEND (limited by PROGB.E)\
SMRTMVD	E036	Relocate with symbols (FF>=89 to enable)\
PCSRC		sub: if SRCBEG specified, move to PCL; else move PCL to SRCBEG\
			and SRCEND. Either way, sec if SRCBEG <> SRCEND\
FZEROS		sub: move SRCEND forward until it points to BITCOUNT zeros\
MONINS	E063	Insert operator\
MONKLS	E066	Klose operator\
PHRNG		sub: save move range to stack\
PLRNG		sub: restore move range from stack\
PRNG			sub: print DSTBEG<SRCBEG.SRCEND\
CALCLEN		sub: calc MOVELEN and DSTEND\
SAVEPCL		sub: save PCL on stack\
ADRPTCH		patch: don't print label if immediate fmt\
FMTPTCH	E069	patch: save format in PSYM\
FILTLABL		patch: check for shorter label not separated by space;\
			if not, check for probable label, ERR if so.\
LOADPROG		Load 1000-3FFF from tracks 5-7\
SAVEPROG		Save 1000-3FFF to tracks 5-7\
MONQUOTE	E06F	Process quote command\
MONSRCH	E075	Process search command\
DATPTCH1	E078	ASCII dump patch\
DATPTCH2	E07B	"\
DATPTCH3	E07E	"\
DATFLUSH		"\
PRLBORNUM	Print num in SRCBEG ($3C/3D), with PTMP bytes (1 or 2).\
			If label+-0/1/2 or PC+-0/1/2, print that instead.\
NODOLLARS	Patch: don't print $ in normal disassembly (we only want one\
			if not a label)\
CKSYMORPC	Check SRCBEG if label or PCL. If so print and SEC; else clc.\
		EF2C	<next>\
\
********\
\
Helpful info for move/relocation routines:\
	3C: SRCBEG: source begin\
	3E: SRCEND: source end\
	42: DSTBEG: target begin\
	50: PTMP\
	52: QTMP\
	58: PROGBEG\
	5A: PROGEND\
	5C: MOVELEN\
	5E: TARGET\
	60: DSTEND\
\
String table\
	F400	Print string,X\
	--0C	"FULL "\
	--12	"[cr]SMARTMV "\
	--1C	" SYMS, "\
	--24	" INSTRS"\
	--2C	"P-RANGE "\
	--36	"TIGHT: INS MORE"\
	--46	"[cr] FREE SECS: "\
	--53	"(RD SYM)"\
	--5C	"(WR SYM)"\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f1\fs20 \cf0 Script used to relocate Super-mon to low mem ($4000.5FFF), so that one can work on the upper Super-mon:\
\
4000.5FFFP\
4000<E000.FFFFS\
54C0.54FFZ\
F500<5500.57FFS\
540C<F40C.F4FFM\
5962<F962.FA42M\
COLDST+7:40\
COLDST+1B:40\
MONLUP+1:A5\
SETVID+15:5D\
GETNUM+18:5E\
MKINSG\
C600G\
4000G\
E000.F3FFP\
\
(the reboot is to restore the symbol table for upper Super-mon)\
\
Files:\
  DF01: Init; $1800 loads Super-mon and sym tbl; \
              $1940 regenerates the patch and saves saves them.\
  DF02: Super-mon [E000.F7FF]\
  DF03: Sym tbl 1 [D000.DFFF, C083]\
  DF04: Sym tbl 2 [D000.DFFF, C08B]\
\
\
\
}