```
CHEATSHEET: A,A1:ADR/SYM, V:VAL/SYM  [B]
            F,F1:FILE/SYM (DF01.DFFD)
------MEMORY-------  ------CODING-------
A1       DUMP BYTE   A1: OP   ASSEMBLE
A1.A2     "   RANGE    (^ NOTE SPACE)
ADR:V    SET BYTE    A2: OP V
:V V...   "  BYTES    OP2     SPACE: ASM
:"STR"    "  STRING   BRX *   FWD BRNCH
A1.A2Z   ZERO RANGE  X        FIX FWD BR
V<A1.A2Z FILL RANGE  -----CHANGING------
A<A2.A3M MOVE RANGE  A1.A2P   SET PROG
A<A2.A3V COMPARE     A1I      INSERT ONE
------SYMBOLS------  A1O      OPEN ONE
SYM=A1   SET SYMBOL  A1.A2I   INS RANGE
SYM=0    CLEAR SYM   A1K      DEL ZEROS
SYM+V    ADD (-SUB)  A1.A2K   DEL RANGE
A1.A2T   SHOW SYMS   A<A2.A3S SMART MOVE
A1.A2!   CLEAR SYMS  A1.A2?   FIND REFS
------LIST/RUN-----  ------NAKEDOS------
A1L      LIST CODE   R        CATALOG
-G .. -Z LINE MARKS  A1<F1R   READ FILE
A1G      RUN CODE    F<A1.A2W WRITE FILE
^E       PRINT REGS  F1W      WRITE PROG
:V V     ...AND SET  F1<0W    DEL FILE

SUPER-MON FEATURES                   [C]

SUPER-MON MAKES PROGRAMMING FUN! FUSES
SOME OF THE POWER OF ASSEMBLERS WITH THE
JOY OF INSTANT FEEDBACK AND THE GOOD OLD
"BARE METAL" FEEL OF THE SYSTEM MONITOR.

- DEFINE 3-9 CHARACTER SYMBOLS TO STAND
  FOR ADDRESSES, THEN USE THEM ANYWHERE.

- INTEGRATED MINI ASSEMBLER (W/ LABELS!)

- "SMART MOVE" FIXES SYMBOLS, BRANCHES
  AND ABSOLUTE REFERENCES.

- HANDY INSERT/DELETE COMMANDS AND
  SHORTCUT "LINE MARKS" REDUCE TYPOS.

- FIND REFERENCES TO A SYMBOL OR RANGE.

- INTEGRATED WITH NAKEDOS FOR FAST AND
  EASY DISK I/O, WITH TONS OF FREE RAM.

- BUILT-IN SUPPORT FOR "SHORT" LANGUAGE

MEMORY MAP                           [D]

0000.00FF  ZERO PAGE
              00.1F FREE
              20.63 SUPER-MON
              64.FF FREE
0100.01FF  STACK
0200.02FF  INPUT BUFFER

0300.032F  FREE

0320.03EF  NAKEDOS STUB
0340       NAKEDOS ENTRY POINT
03F0.03FF  SYSTEM VECTORS
0400.07FF  SCREEN STORAGE

0800.17FF  FREE / NAKEDOS
            (OVERWRITTEN DURING DOS OPS)
1800.BFFF  FREE

C000.CFFF  I/O SPACE
D000.F7FF  SUPER-MON
F800.FFFF  SYSTEM MONITOR

SUPER-MON COMMANDS                   [E]

          == DUMPING MEMORY ==

#1111           DUMP HEX AND ASCII @ ADR
#               DUMP UP TO 8 ADD'L BYTES
#1111.2222      DUMP RANGE OF ADDRESSES

          == CHANGING MEMORY ==

#1111:22 33...  PUT VALUES IN MEMORY
#:44 55 66...   CONTINUE PUTTING VALUES
#1111:"STRING"  ASCII VALUES ARE NICE
#1111.2222Z     FILL ("ZAP") RANGE W/ 0
#11<2222.3333Z  FILL RANGE WITH A VALUE

          == MOVING, COMPARING ==

#111<222.333M   MOVE (COPY) RANGE OF MEM
                 E.G. 222.333 -> 111.222
                 (HANDLES OVERLAPPING
                  RANGES CORRECTLY)
#111<222.333V   COMPARE TWO MEM RANGES,
                 SHOW BYTES THAT DIFFER

SUPER-MON COMMANDS                   [F]

             == SYMBOLS ==

#SYM=1111       SET A SYMBOL
#SYM=0          CLEAR A SYMBOL
#SYM            SHOW VALUE OF SYMBOL
#1111.2222T     SHOW SYMBOLS IN RANGE
#1111.2222!     CLEAR SYMBOLS IN RANGE
#SYM+1111       ADD TO SYMBOL
#SYM-2222       SUBTRACT FROM SYMBOL
#SYM:SYM2 SYM3  SYMBOLS FOR ADDR OR VAL

           == LIST AND RUN ==

#1111L          LIST 22 LINES W/ SYMBOLS
                 AND LINE MARKS (-G..-Z)
#-G .. #-Z      USE LINE MARK FROM PREV
                 LIST FOR ANY ADR OR VAL
                 (HELPS PREVENT TYPOS)
#1111G          RUN PROGRAM
<RESET>         STOP ERRANT PROGRAM
#^E  (CTRL-E)   PRINT 6502 REGISTERS
#:11 22 33      SET REGISTERS AFTER ^E

SUPER-MON COMMANDS                   [G]

           == CREATING CODE ==

#1111: OPC 2222 ASSEMBLE INSTRUCTION
                 (NOTE SPACE AFTER ":")
# OPC (SYM),Y   CONTINUE ASSEMBLY
# OPC *+4       * IS CURRENT PROGRAM CTR
# BXX *         SPECIAL: FORWARD BRANCH
# ...
#1111X          FIX PREV FORWARD BRANCH
#X               (SHORT FORM: TO CUR PC)

           == PROGRAM AREA ==

#2000.3FFFP     SET PROGRAM AREA

  NOTE: CODE MANIPULATION COMMANDS
  SCAN THIS AREA (DEFAULT 6000.BFFF)
  TO LOCATE AND/OR ADJUST:

     1. RELATIVE BRANCH REFERENCES
     2. ABSOLUTE CODE REFERENCES
     3. SYMBOL VALUES

SUPER-MON COMMANDS                   [H]

         == MANIPULATING CODE ==

#1111I          INSERT 64 ZEROS AT ADDR
#1111.1122I     INSERT ZEROS IN RANGE
#1111O          OPEN: INSERT, BUT DON'T
                 MOVE FIRST SYMBOL

#K              DELETE INSTRUCS, PC UP
                 (STOP AT 1ST NON-ZERO)
#1111K          DELETE FROM ADDR UP
#1111.1122K     DELETE RANGE OF INSTRUCS
                 (END ADDR ROUNTED UP TO
                  WHOLE INSTRUCTION)

#111<222.333S   SMART MOVE: MOVE MEMORY,
                 ADJUST REFS & SYMBOLS,
                 ZERO OUT VACATED SPACE

#1111?          FIND REFS TO ADDR
#1111.2222?     FIND REFS TO RANGE


SUPER-MON COMMANDS                   [I]

 == WORKING WITH DISKETTES (NAKEDOS) ==

  NOTE: FILE NUMBERS MUST BE DF01.DFFD

#R              SHOW DISK CATALOG
#DF11R          READ FILE TO PROG. AREA
                 (AND READ SYMBOL TABLE)
#1111<DF22R     READ FILE TO ADDRESS
                 (ENTIRE FILE ONLY)

#XYZ<DF22R      HANDY TO USE SYMBOLS
#XYZR           ...FOR EASIER COMMANDS

#DF33W          WRITE PROG. AREA TO FILE
                 (AND WRITE SYM TABLE)
#XYZ<1100.22FFW WRITE RANGE TO FILE
                 (WHOLE PAGES ONLY)

#DF44<0W        DELETE A FILE

#1800<DF01R     FILE 01 IS SPECIAL, RUNS
                ON BOOT AT ADDR 1800

SUPER-MON COMMANDS                   [J]

          == MISCELLANEOUS ==

#I             SET INVERSE TEXT
#I             SET NORMAL TEXT

#1^P (CTRL-P)  OUTPUT TEXT TO SLOT
#1^I (CTRL-I)  INPUT TEXT FROM SLOT

#11+22         8-BIT ADD
#44-33         8-BIT SUBTRACT

#SYM+1111      16-BIT MATH: SYMBOLS ONLY
#SYM-1111        "

#^Y  (CTRL-Y)  JMP TO USER CMD AT 03F8

#1111$         CONVERT DECIMAL TO HEX
#$2222         CONVERT HEX TO DECIMAL

NOTE: DEC-TO-HEX AND BACK REQUIRE
      "SHORT" SUPPORT TO BE PRESENT.

NAKEDOS FEATURES                     [K]

WELCOME! NAKEDOS PROVIDES A SIMPLE BUT
COMPLETE INTERFACE TO THE DISK ][ DRIVE.
OPTIMIZED FOR USE IN ASSEMBLY-LANGUAGE
PROGRAMS, SOME FEATURES ARE:

- TINY ON DISK: ONLY 3K (INCL. CATALOG)

- TINY IN MEMORY: 192 BYTES WHEN NOT
  OPERATING; ADDITIONAL 4K DURING OPS.

- VERY FAST: READ 4.3 TRACKS PER SECOND
            WRITE 3.3 TRACKS PER SECOND

- BEST API: EASY TO READ AND REMEMBER,
  MADE JUST FOR ASSEMBLY LANGUAGE.

- SIMPLE FILE SYSTEM WITH EFFICIENT AND
  FLEXIBLE ALLOCATION.

- EMULATOR COMPATIBLE: USE .DSK FORMAT

- WRITTEN FROM SCRATCH; NO APPLE CODE.

NAKEDOS ASSEMBLY API                 [L]

THE GENERAL FORM OF A NAKEDOS CALL IS:

 JSR $340     ; ALWAYS $340
 ADC $DCXX    ; XX IS THE OPERATION #
 ...PARAMS... ; SEE BELOW
 ADC $DCXX    ; CAN CHAIN MULTIPLE CMDS
 ...PARAMS...
 CLD          ; TERMINATES THE CHAIN

PARAMETERS ARE ALWAYS 8 BITS AND SPECI-
FIED BY A SUBSET OF 6502 OPCODES THAT
NAKEDOS INTERPRETS SPECIALLY:

 LDA #$11     ; IMMEDIATE VALUE
 LDA $22      ; LOAD VALUE FROM ZERO PG
 LDA $3333    ; LOAD VALUE FROM ABS ADDR
 BIT $4400    ; TAKE HIGH BYTE (EG $44)
 BIT $0055    ; TAKE LOW BYTE (EG $55)

THE LATTER TWO FORMS ARE NICE FOR MAKING
SYMBOLIC REFERENCES TO MEMORY PAGES AND
FILE NUMBERS (RESPECTIVELY.)

NAKEDOS ASSEMBLY API                 [M]

        == SUPPORTED COMMANDS ==

 ADC $DC01  READ FILE (ENTIRE FILE)
 <FILE#>      NUMBER (01.FD) OF FILE
 <MEMPAGE>    STARTING MEMORY PAGE

 ADC $DC02  WRITE FILE
 <FILE#>      NUMBER (01.DF) OF FILE
 <MEMPAGE>    STARTING MEMORY PAGE
 <NPAGES>     NUMBER OF PAGES TO WRITE

 ADC $DC03  DELETE FILE
 <FILE#>      NUMBER (01.DF) OF FILE

 ADC $DC08  GET FILE INFO
 <FILE#>      NUMBER (01.DF) OF FILE
            AFTER CALL, ACCUMULATOR HAS
            FILE LENGTH, OR 0 FOR NONE.

 ADC $DC0F  INITIALIZE CATALOG (DELETE
              ALL FILES)

NAKEDOS ASSEMBLY API                 [N]

 ADC $DC41  RAW DISK READ
 <TRACK#>     STARTING TRACK (00.22)
 <SECTOR#>    STARTING SECTOR (00.0F)
 <MEMPAGE>    STARTING MEMORY PAGE
 <NPAGES>     NUMBER OF PAGES TO READ

 ADC $DC42  RAW DISK WRITE
 <TRACK#>     STARTING TRACK (00.22)
 <SECTOR#>    STARTING SECTOR (00.0F)
 <MEMPAGE>    STARTING MEMORY PAGE
 <NPAGES>     NUMBER OF PAGES TO WRITE

 CLD        DONE WITH DISK COMMANDS
              (TURNS OFF DRIVE, CLEARS
               NAKEDOS BUFFERS, RETURNS)

 SED        PAUSE
              (LEAVES DRIVE ON, NAKEDOS
               STAYS IN MEM, RETURNS.
               SUBSEQENT OPS ARE QUICK)

 CLV        PAUSE BUT TURN OFF DRIVE

NAKEDOS ASSEMBLY API                 [O]

             == EXAMPLE ==

THIS EXAMPLE COPIES FILE $DF10 TO DF20.
IT FIRST GETS THE FILE LENGTH, THEN
READS TO A BUFFER AT $4000, AND WRITES
FROM THAT SAME BUFFER.

 JSR $340    ; CALL NAKEDOS
 ADC $DC08   ; FILE INFO
 BIT $DF10   ; FILE NUMBER $10
 SED         ; LEAVE ON, RESUME 6502 ASM
 STA $6      ; STORE FILE LENGTH
 JSR $340    ; BACK TO NAKEDOS
 ADC $DC01   ; READ FILE
 BIT $DF10   ; FILE NUMBER $10
 LDA #$40    ; PAGE $40 (E.G. ADDR 4000)
 ADC $DC02   ; WRITE FILE
 LDA #$20    ; FILE NUMBER $20
 BIT $4000   ; PAGE $40 SAID ANOTHER WAY
 LDA $6      ; RETRIEVE FILE LENGTH
 CLD         ; ALL DONE

NAKEDOS INTERNALS                    [P]

      == TRACK 0 DISK SECTORS ==

  0: BOOTSTRAP ROUTINE (WITH STUB)
1-9: MAIN NAKEDOS CODE
A-C: DISK CATALOG STARTING AT OFFSET $D0
     OF SECTOR A, THRU END OF SECTOR C.

         == CATALOG FORMAT ==

ONE BYTE PER SECTOR (16 BYTES PER TRK).

     00: ILLEGAL VALUE
  01.FD: SECTOR BELONGS TO CORRESP. FILE
     FF: FREE
     FE: NAKEDOS RESRVD: TRK 0, SECS 0.C

            == GENERAL ==

- SECTORS ARE 6/2 CODED AS IN DOS/PRODOS
- NO SKEW / INTERLEAVING
- NAKEDOS DOES SCATTER READ/WRITE (WORKS
  ON WHATEVER SECTOR IS UNDER THE HEAD)

NAKEDOS INTERNALS                    [Q]

           == MEMORY USE ==

 0320.3EF: STUB LOADER. CALLING $340
           (NOT $320) READS NAKEDOS FROM
           TRACK ZERO, JUMPS TO IT. USES
           SLOT 6 ROM AS SUBROUTINE.

THE FOLLOWING AREAS ARE ONLY USED DURING
DISK OPERATIONS, AND CAN BE USED AT ALL
OTHER TIMES BY USER PROGRAMS.

 0026.002B  ZERO-PAGE POINTERS
 0800.0E3F  BUFFERS AND LOOKUP TABLES
 0E40.158F  MAIN NAKEDOS CODE
 1590.15CF  VARIABLES
 15D0.17FF  DISK CATALOG

LICENSE                              [R]

SUPER-MON, NAKEDOS AND SHORT ARE ALL
PROVIDED UNDER THE (CC)ZERO LICENSE.

IN LAYMAN'S TERMS IT ESSENTIALLY MEANS
"PUBLIC DOMAIN" - USE THIS SOFTWARE
HOWEVER, WHEREVER AND WHENEVER YOU WISH.

IN SPECIFIC LEGAL TERMS:

- TO THE EXTENT POSSIBLE UNDER LAW,
  MARTIN HAYE HAS WAIVED ALL COPYRIGHT
  AND RELATED NEIGHBORING RIGHTS TO
  SUPER-MON, NAKEDOS AND SHORT. THESE
  WORKS ARE PUBLISHED FROM THE
  UNITED STATES.

SHORT FEATURES (1 OF 2)              [B]

SOMETIMES YOU DON'T NEED ALL THE SPEED &
POWER OF ASSEMBLY, BUT BASIC OR PASCAL
WOULD BE OVERKILL.

"SHORT" IS THE ANSWER. ONE STEP UP FROM
CODING IN ASSEMBLY, SHORT IS A BRAND NEW
PROGRAMMING LANGUAGE FOR THE APPLE II!

- 1K RUNTIME AND A TINY FOOTPRINT; PROGS
  ARE BRIEF TO TYPE, SMALL TO STORE.

- STRUCTURED PROGRAMMING SUPPORT: LOCAL
  VARS, NESTED FUNCTIONS W/ PARAMETERS

- SMALLER THAN BASIC & TWICE AS FAST

- FREELY MIX SHORT WITH 6502 ASSEMBLY;
  EASY TO SWITCH BACK AND FORTH

- FULL SET OF 16-BIT MATH & LOGICAL OPS

          (MORE FEATURES ON NEXT PAGE.)

SHORT FEATURES (2 OF 2)              [C]

- ARRAY AND STRUCTURE OPS

- FULLY INTEGRATED. CODE AND REVISE IN
  SUPER-MON AS NORMAL (ASSEMBLE, MOVE,
  RESIZE, RUN, SEARCH, ETC.)

- FOR READABILITY: COMMENTS, VAR ASSIGN-
  MENT, STRINGS, DECIMAL INTS

- LIBRARY INCL: LOOP/WHILE/STEP, IFT,
  PRSTR, PRINTF, PTR, MEMCPY, ETC.

WHAT DOES'T IT HAVE? WELL, A LOT. BASIC
FOR INSTANCE HAS: MEMORY MANAGEMENT,
GRAPHICS, STRING MODIFICATION, FLOATING
POINT, ETC.

STILL, FOR WRITING UTILITIES, SHORT IS
GREAT.

THE BASICS (1 OF 3)                  [D]

THE MECHANICS OF CREATING A PROGRAM IN
SHORT ARE A LOT LIKE MAKING AN ASSEMBLY
PROGRAM IN SUPER-MON. EACH STATEMENT HAS
AN ADDRESS IN MEMORY. HERE'S A "HELLO
WORLD" PROGRAM TO ENTER INTO SUPER-MON:

#1C00<FSHORTR
#8000: PRSTR("HELLO WORLD")
# RTS

FIRST WE LOAD THE SHORT RUNTIME AT ITS
DEFAULT ADDRESS OF $1C00.

NEXT WE TELL PUT OUR PROGRAM AT ADDRESS
$8000. WE JUST PRINT A STRING, USING
"PRSTR", PART OF SHORT'S LIBRARY.

FINALLY WE RETURN FROM OUR LITTLE SUB-
ROUTINE. NOTE WE SIMPLY USE A 6502 "RTS"
OPCODE; THIS IS A GOOD EXAMPLE OF HOW
EASY IT IS TO MIX SHORT AND ASSMEMBLY
TOGETHER.

THE BASICS (2 OF 3)                  [E]

TO LIST THE PROGRAM:

#8000L

8000-G  PRSTR("HELLO WORLD")
8010-H  60        RTS
8011-I  FF        ???
...ETC...

NOW LET'S RUN THE PROGRAM:

#8000G
HELLO WORLD
#

HOUSEKEEPING IS IMPORTANT WHEN STARTING
A PROGRAM SO IT WILL BE EASY TO EDIT.
ESTABLISH THE AREA OF MEMORY TO USE FOR
YOUR PROGRAM, AND THEN CLEAR IT OUT.

#8000.8FFFP
#8000.8FFFZ

THE BASICS (3 OF 3)                  [F]

LET'S USE VARIABLES AND DO SOME MATH:

#NUMBER=80
#PRODUCT=82

THIS DEFINES TWO LABELS (IN SUPER-MON)
THAT WE CAN USE AS VARIABLES TO STORE
VALUES.

#8000: NUMBER=3251
# PRODUCT=NUMBER*2
# PRINTF("THE BEST IS %D",PRODUCT)
# RTS
#8000G
THE BEST IS 6502

NOW WE PUT VALUES IN THOSE VARIABLES,
INCLUDING A COMPUTATION, AND PRINT USING
THE "C"-LIKE PRINTF LIBRARY FUNCTION. IN
THIS, THE "%D" CODE GETS REPLACED BY THE
VALUE WE COMPUTED.

FLOW OF CONTROL (1 OF 2)             [G]

IN SHORT THERE ARE TWO WAYS (IN ADDITION
TO JSR, JMP, AND OTHER 6502 BRANCHES) TO
AFFECT THE FLOW OF THE PROGRAM.

FIRST IS "IFT":

#8000: NUMBER=1
# IFT(NUMBER>1,*)
# PRSTR("FOO")
#X

HERE WE STICK 1 INTO A VARIABLE, THEN
WE USE THE "IFT" LIBRARY FUNCTION TO
TEST ITS VALUE AND BRANCH IF IT'S MORE
THAN 1. WHICH IT'S NOT, SO THE BRANCH IS
NOT TAKEN, SO "FOO" IS *NOT* PRINTED.

NOTE HOW WE MADE A FORWARD BRANCH... THE
NORMAL WAY IN SUPER-MON: USE "*" AS A
PLACEHOLDER, THEN REPAIR IT LATER USING
THE "X" COMMAND.

FLOW OF CONTROL (2 OF 2)             [H]

HERE'S THE SHORT WAY TO DO A LOOP:

#8000: NUMBER=1
# ;PRINT THE NUMBERS 1 TO 9
# LOOP()
# PRDEC(NUMBER)
# WHILE(STEP(NUMBER,1,10))
# RTS

THE "LOOP" FUNCTION MARKS THE START OF
YOUR LOOP, AND "WHILE" MARKS THE END. IT
WILL EXECUTE ONCE, AND THEN LOOP AGAIN
IF THE CONDITION IS TRUE.

IN THIS CASE OUR CONDITION MAKES USE OF
"STEP" WHICH INCREMENTS A VARIABLE BY
SOME NUMBER, THEN CHECKS IF THE RESULT
IS LESS THAN ANOTHER NUMBER.

ALSO NOTE THAT SHORT ENCOURAGES COMMENTS
IN YOUR CODE: JUST START THEM WITH A
";" MARKER.

MAKING FUNCTIONS (1 OF 3)            [I]

A FOUNDATIONAL TOOL IN WRITING A STRUC-
TURED PROGRAM IS BREAKING DOWN TASKS TO
"FUNCTIONS", EACH DOING A SMALLER TASK.

FUNCTIONS IN SHORT BEGIN WITH A DEFINI-
TION DECLARING HOW MANY PARAMETERS IT
TAKES AS INPUT AND WHERE TO PUT THEM.

#8000: DEF SQUARE(NUMBER)
# RETURN(NUMBER*NUMBER)

THIS FUNCTION TAKES ONE PARAMETER, WHICH
WILL BE STORED IN THE VARIABLE "NUMBER".
IT DOES ONLY ONE THING: RETURN THE
SQUARE OF THE NUMBER.

TO CALL IT:

#8010: PRINTF("ANSWER: %D", SQUARE(16))
# RTS
#8010G
ANSWER: 256

MAKING FUNCTIONS (2 OF 3)            [J]

ALSO IMPORTANT IS KEEPING A FUNCTION'S
OPERATION ISOLATED FROM OTHER FUNCTIONS.

LOCAL VARIABLES FACILITATE THIS:

#8000: DEF FUNC()
# LOCAL(TMP,8)
# TMP=TMP*TMP
# RETURN(TMP)
#8020: PRDEC(FUNC())
# RTS
#8020G
64

THE "LOCAL" FUNCTION DECLARES SAVES THE
VALUE OF THE GIVEN VARIABLE AND SETS IT
TO A NEW VALUE. MOST IMPORTANT, IT
ARRANGES SO THE VARIABLE'S PREVIOUS
VALUE WILL BE RESTORED WHEN THE FUNCTION
RETURNS.

MAKING FUNCTIONS (3 OF 3)            [K]

A FUNCTION IN SHORT CAN ACCEPT 0, 1, 2
OR 3 PARAMETERS. ALL PARAMETERS MUST BE
ON ZERO PAGE (I.E. ADDRESS $00..FF).

NOTE THAT LOCAL VARIABLES CAN BE ANY-
WHERE IN MEMORY, NOT JUST ZERO PAGE.

IF YOU DISASSEMBLE A SHORT FUNCTION
OUTSIDE OF SUPER-MON YOU'LL SEE IT
BEGINS SIMPLY WITH A JSR TO ONE OF THE
SHORT ENTRY POINTS. SHORT SAVES THE
ORIGINAL VALUES OF THE PARAMETER
VARIABLES, STORES THE NEW VALUES AND
RETURNS.

THUS, THE CONTENTS OF A FUNCTION CAN BE
ALL 6502 CODE, OR ALL SHORT CODE, OR
ANY MIX OF THE TWO.

REFERENCE: OPERATORS                 [L]

ALL SHORT VARIABLES AND OPS ARE 16-BIT
(2-BYTE) UNSIGNED QUANTITIES.

+  ADD              <  LESS THAN
-  SUBTRACT         <= LESS OR EQUAL
*  MULTIPLY         >  GREATER THAN
/  DIVIDE           >= GREATER OR EQUAL
%  MODULO           == EQUAL
<< SHIFT LEFT       != NOT EQUAL
>> SHIFT RIGHT
&  LOGICAL AND      ]  INDEX WORD ARRAY
@  LOGICAL OR       .  INDEX BYTE STRUCT
^  LOGICAL XOR

ARRAY: X]Y ACCESSES THE Y'TH WORD IN
  THE ARRAY REFERED TO BY POINTER X

STRUCT: X.Y ACCESSES THE Y'TH BYTE IN
  STRUCTURE REFERED TO BY PTR X. ONLY
  THE LOWER BYTE OF Y IS USED SO THE
  UPPER BYTE CAN BE USED TO MAKE IT A
  UNIQUE LABEL.

REFERENCE: LIBRARY FUNCS (1 OF 5)    [M]

NOTE: LOCATIONS ARE GIVEN ASSUMING
  SHORT'S DEFAULT LOCATION OF $1C00.1FFF

POINTER-RELATED FUNCTIONS
=========================

PTR(LABEL) - $1E3C - RETURN LABEL AS
  A POINTER ADDRESS, SUITABLE FOR USE
  IN *PB FUNCTIONS BELOW OR AS STRINGS

GETPB(PTR) - $1E44 - GET ONE BYTE FROM
  THE GIVEN POINTER ADDRESS

SETPB(PTR,VAL) - $1E4C - WRITE THE LOWER
  BYTE OF VAL TO THE GIVEN PTR ADDRESS

MEMSET(DSTPTR,LENGTH,VALUE) - $1FB5 -
  SET A RANGE OF MEMORY TO A VALUE

MEMCPY(DSTPTR,LENGTH,SRCPTR) - $1DFF -
  COPY A RANGE OF MEMORY. NOTE: IF OVER-
  LAPPING, WORKS ONLY IF DST < SRC.

REFERENCE: LIBRARY FUNCS (2 OF 5)    [N]

LOOPING FUNCTIONS
=================

LOOP() - $1F5F - PUSH CURRENT PROGRAM
  COUNTER ON THE STACK.

WHILE(COND) - $1F6E - IF CONDITION IS
  NON-ZERO, JUMP TO PROGRAM COUNTER
  FROM THE STACK. OTHERWISE POP IT.


INCREMENT / DECREMENT
=====================

INCW(VAR) - $1E60 - INCREASE VARIABLE
  BY ONE, RETURN ITS FINAL VALUE

DECW(VAR) - $1E6B - DECREASE VARIABLE.

STEP(VAR,NUMBER,LIMIT) - $1F80 -
  INCREASE VAR BY NUMBER, THEN RETURN 1
  IF THE RESULT IS LESS THAN LIMIT.

REFERENCE: LIBRARY FUNCS (3 OF 5)    [O]

INPUT / OUTPUT
==============

PRSTR(STR) - $1EC6 - PRINT A HIGH-ASCII
  STRING, STOP AT TERMINATING ZERO.

PRHEX(NUM) - $1E8C - PRINT HEX NUMBER

PRDEC(NUM) - $1E92 - PRINT DECIMAL NUM

PRINTF(FORMAT,VAR) - $1ECB - PRINT A
  FORMATTED STRING. WITHIN IT SHOULD BE
  ONE OF THE FOLLOWING % CODES TO
  SPECIFY HOW TO PRINT VAR:

  %D - DECIMAL NUMBER
  %X - HEX NUMBER (4 CHARS)
  %S - STRING

READKEY() - $1FE3 - READ A KEY FROM THE
  KEYBOARD, RETURN IT'S NUMERIC HIGH
  ASCII CODE (128-255)

REFERENCE: LIBRARY FUNCS (4 OF 5)    [P]

USE IN FUNCTIONS
================

LOCAL(VAR,INITVAL) - $1F23 - PUSH VAR'S
  CURRENT VALUE ON THE STACK, SET IT
  TO INITVAL, AND ARRANGE SO THAT THE
  ORIGINAL VALUE WILL BE RESTORED WHEN
  THE CURRENT FUNCTION RETURNS.

RETURN(VALUE) - $1F0D - PLACE VALUE IN
  A-REG (HIGH) AND X-REG (LOW BYTE),
  THEN RETURN TO CALLING FUNCTON.

LIMITS
======

MIN(VAL1,VAL2) - $1FAE - RETURN THE
  LOWER NUMBER, VAL1 OR VAL2.

MAX(VAL1,VAL2) - $1F98 - RETURN THE
  HIGHER NUMBER, VAL1 OR VAL2.

REFERENCE: LIBRARY FUNCS (5 OF 5)    [Q]

LOGICAL
=======

IFT(COND,LABEL) - $1E78 - IF COND IS >
  NONZERO, JUMP TO LABEL. OTHERWISE DO
  NOTHING.

IFNOT(COND,LABEL) - $1E84 - IF COND IS 0
  THEN JUMP TO LABEL; ELSE DO NOTHING.

NOT(COND) - $1E54 - RETURN 1 IF COND IS
  0, ELSE RETURN 0.

RELOCATING SHORT                     [R]

THE SHORT RUNTIME NORMALLY LIVES AT
$1C00.1FFF. YOU CAN USE SUPER-MON TO
MOVE IT ANYWHERE YOU LIKE.

THE MAIN RULES:
- MAKE SURE THE SHORT RUNTIME IS
  *OUTSIDE* YOUR PROGRAM RANGE
- MAKE SURE THE DESTINATION LOCATION
  IS *INSIDE* YOUR PROGRAM RANGE.

LET'S SAY YOU HAVE A SHORT PROGRAM AT
$8000 USING THE DEFAULT RUNTIME, AND
YOU WANT TO MOVE THE RUNTIME TO $BC00:

#8000.BFFFP
#BC00<1C00.1FFFS

THAT'S IT!

BARE FUNCTIONS                       [S]

NORMAL SHORT FUNCTIONS YOU MAKE CAN BE
CALLED "DECORATED": THEY SPECIFY WHERE
THEIR PARAMETERS SHOULD BE STORED. IT IS
POSSIBLE HOWEVER TO MAKE "BARE" SHORT
FUNCTIONS. THESE ARE FASTER AND SMALLER,
BUT HARDER TO MAKE AND MAINTAIN.

TO MAKE A BARE FUNCTION CALL ONE OF THE
FOLLOWING ENTRY POINTS DEPENDING ON HOW
MANY ARGUMENTS YOU WANT TO ACCEPT:

  SHORT0 - $1C00    SHORT2 - $1C08
  SHORT1 - $1C04    SHORT3 - $1C0C

THE ARGUMENTS WILL BE PLACED HERE:

  ARG0 - $64     PARG0 - $66
  ARG1 - $68     PARG1 - $6A
  ARG2 - $6C     PARG2 - $6E

NOTE THESE ARE *NOT* SAVED DURING SHORT
CALLS... INCLUDING COMMENTS! BEWARE.

INTERNALS                            [T]

ZERO-PAGE USAGE
===============

SHORT UTILIZES PART OF SUPER-MON'S SPACE
PLUS $63.6F. SO IT'S SAFE TO PUT YOUR
VARIABLES IN $00.1F AND $70.FF.

MAIN MEMORY USAGE
=================

SHORT LEAVES ALL OF MAIN MEMORY FREE FOR
YOUR PROGRAMS AND VARIABLES. HOWEVER,
DUE TO SHORT'S ENCODING, CERTAIN
PRACTICES MAKE SLIGHLY SMALLER PROGRAMS:

- USE ZERO-PAGE VARIABLES
- USE MAIN-MEMORY VARIABLES ABOVE $4000
- PUT YOUR PROGRAM ABOVE $4000

(MORE INTERNALS TO COME IN A FUTURE
 RELEASE...)
```